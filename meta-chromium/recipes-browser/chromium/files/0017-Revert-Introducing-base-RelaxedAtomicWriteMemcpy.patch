From 62ae5ac22de9435cd2fd9150b5d5e3357d8fc010 Mon Sep 17 00:00:00 2001
From: Ariel D'Alessandro <ariel.dalessandro@collabora.com>
Date: Sat, 26 Apr 2025 18:01:39 -0300
Subject: [PATCH] Revert "Introducing base::RelaxedAtomicWriteMemcpy"

| FAILED: obj/base/base/atomicops.o
| ../../base/atomicops.cc:20:22: error: no member named 'atomic_ref' in namespace 'std'
|    20 |   static_assert(std::atomic_ref<uint8_t>::required_alignment == 1);
|       |                 ~~~~~^

This reverts commit d29b01737a841b5627249d50f007dcdc7e26462b.
---
 base/BUILD.gn              |  1 -
 base/atomicops.cc          | 65 --------------------------------------
 base/atomicops.h           | 25 ---------------
 base/atomicops_unittest.cc | 23 --------------
 4 files changed, 114 deletions(-)
 delete mode 100644 base/atomicops.cc

diff --git a/base/BUILD.gn b/base/BUILD.gn
index 4aa6fa7b81..6c259dad25 100644
--- a/base/BUILD.gn
+++ b/base/BUILD.gn
@@ -183,7 +183,6 @@ component("base") {
     "at_exit.h",
     "atomic_ref_count.h",
     "atomic_sequence_num.h",
-    "atomicops.cc",
     "atomicops.h",
     "atomicops_internals_atomicword_compat.h",
     "atomicops_internals_portable.h",
diff --git a/base/atomicops.cc b/base/atomicops.cc
deleted file mode 100644
index 7b6aca4d6c..0000000000
--- a/base/atomicops.cc
+++ /dev/null
@@ -1,65 +0,0 @@
-// Copyright 2024 The Chromium Authors
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#include "base/atomicops.h"
-
-#include <atomic>
-
-#include "base/memory/aligned_memory.h"
-
-namespace base::subtle {
-
-void RelaxedAtomicWriteMemcpy(base::span<uint8_t> dst,
-                              base::span<const uint8_t> src) {
-  CHECK_EQ(dst.size(), src.size());
-  size_t bytes = dst.size();
-  uint8_t* dst_byte_ptr = dst.data();
-  const uint8_t* src_byte_ptr = src.data();
-  // Make sure that we can at least copy byte by byte with atomics.
-  static_assert(std::atomic_ref<uint8_t>::required_alignment == 1);
-
-  // Alignment for uintmax_t atomics that we use in the happy case.
-  constexpr size_t kDesiredAlignment =
-      std::atomic_ref<uintmax_t>::required_alignment;
-
-  // Copy byte-by-byte until `dst_byte_ptr` is not properly aligned for
-  // the happy case.
-  while (bytes > 0 && !IsAligned(dst_byte_ptr, kDesiredAlignment)) {
-    std::atomic_ref<uint8_t>(*dst_byte_ptr)
-        .store(*src_byte_ptr, std::memory_order_relaxed);
-    // SAFETY: We check above that `dst_byte_ptr` and `src_byte_ptr` point
-    // to spans of sufficient size.
-    UNSAFE_BUFFERS(++dst_byte_ptr);
-    UNSAFE_BUFFERS(++src_byte_ptr);
-    --bytes;
-  }
-
-  // Happy case where both `src_byte_ptr` and `dst_byte_ptr` are both properly
-  // aligned and the largest possible atomic is used for copying.
-  if (IsAligned(src_byte_ptr, kDesiredAlignment)) {
-    while (bytes >= sizeof(uintmax_t)) {
-      std::atomic_ref<uintmax_t>(*reinterpret_cast<uintmax_t*>(dst_byte_ptr))
-          .store(*reinterpret_cast<const uintmax_t*>(src_byte_ptr),
-                 std::memory_order_relaxed);
-      // SAFETY: We check above that `dst_byte_ptr` and `src_byte_ptr` point
-      // to spans of sufficient size.
-      UNSAFE_BUFFERS(dst_byte_ptr += sizeof(uintmax_t));
-      UNSAFE_BUFFERS(src_byte_ptr += sizeof(uintmax_t));
-      bytes -= sizeof(uintmax_t);
-    }
-  }
-
-  // Copy what's left after the happy-case byte-by-byte.
-  while (bytes > 0) {
-    std::atomic_ref<uint8_t>(*dst_byte_ptr)
-        .store(*src_byte_ptr, std::memory_order_relaxed);
-    // SAFETY: We check above that `dst_byte_ptr` and `src_byte_ptr` point
-    // to spans of sufficient size.
-    UNSAFE_BUFFERS(++dst_byte_ptr);
-    UNSAFE_BUFFERS(++src_byte_ptr);
-    --bytes;
-  }
-}
-
-}  // namespace base::subtle
diff --git a/base/atomicops.h b/base/atomicops.h
index 7b7efaaf74..19d82f71ff 100644
--- a/base/atomicops.h
+++ b/base/atomicops.h
@@ -51,9 +51,6 @@
 // - libstdc++: captures bits/c++config.h for __GLIBCXX__
 #include <cstddef>
 
-#include "base/base_export.h"
-#include "base/compiler_specific.h"
-#include "base/containers/span.h"
 #include "build/build_config.h"
 
 namespace base {
@@ -141,28 +138,6 @@ Atomic64 NoBarrier_Load(volatile const Atomic64* ptr);
 Atomic64 Acquire_Load(volatile const Atomic64* ptr);
 #endif  // ARCH_CPU_64_BITS
 
-// Copies non-overlapping spans of the same size. Writes are done using C++
-// atomics with `std::memory_order_relaxed`.
-//
-// This is an analogue of `WTF::AtomicWriteMemcpy` and it should be used
-// for copying data into buffers that are accessible from another
-// thread while the copy is being done. The buffer will appear inconsistent,
-// but it won't trigger C++ UB and won't upset TSAN. The end of copy needs to
-// be signaled through a synchronization mechanism like fence, after
-// which the `dst` buffer will be observed as consistent.
-//
-// Notable example is a buffer owned by `SharedArrayBuffer`.
-// While the copy is being done, JS and WASM code can access the `dst` buffer
-// on a different thread. The data observed by JS may not be consistent
-// from application point of view (which is always the case with
-// `SharedArrayBuffer`).
-//
-// Reads from the `src` buffer are not atomic and `src` access
-// should be synchronized via other means.
-// More info: crbug.com/340606792
-BASE_EXPORT void RelaxedAtomicWriteMemcpy(base::span<uint8_t> dst,
-                                          base::span<const uint8_t> src);
-
 }  // namespace subtle
 }  // namespace base
 
diff --git a/base/atomicops_unittest.cc b/base/atomicops_unittest.cc
index 463777d461..954bdc8ed7 100644
--- a/base/atomicops_unittest.cc
+++ b/base/atomicops_unittest.cc
@@ -11,9 +11,7 @@
 
 #include <stdint.h>
 #include <string.h>
-
 #include <type_traits>
-#include <vector>
 
 #include "testing/gtest/include/gtest/gtest.h"
 
@@ -242,24 +240,3 @@ TEST(AtomicOpsTest, Load) {
   TestLoad<base::subtle::Atomic32>();
   TestLoad<base::subtle::AtomicWord>();
 }
-
-TEST(AtomicOpsTest, RelaxedAtomicWriteMemcpy) {
-  std::vector<uint8_t> src(17);
-  for (size_t i = 0; i < src.size(); i++) {
-    src[i] = i + 1;
-  }
-
-  for (size_t i = 0; i < src.size(); i++) {
-    std::vector<uint8_t> dst(src.size());
-    size_t bytes_to_copy = src.size() - i;
-    base::subtle::RelaxedAtomicWriteMemcpy(
-        base::span(dst).first(bytes_to_copy),
-        base::span(src).subspan(i, bytes_to_copy));
-    for (size_t j = 0; j < bytes_to_copy; j++) {
-      EXPECT_EQ(src[i + j], dst[j]);
-    }
-    for (size_t j = bytes_to_copy; j < dst.size(); j++) {
-      EXPECT_EQ(0, dst[j]);
-    }
-  }
-}
