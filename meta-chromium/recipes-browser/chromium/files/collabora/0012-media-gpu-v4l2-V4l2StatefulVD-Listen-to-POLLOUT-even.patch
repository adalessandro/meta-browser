From a333fd3f8007c60e3d0b4f4af890eaa09941a854 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Fri, 13 Oct 2023 21:08:22 +0000
Subject: [PATCH 12/14] media/gpu/v4l2/V4l2StatefulVD: Listen to POLLOUT events

This is a reland of
https://chromium-review.googlesource.com/c/chromium/src/+/4935454
to uncondtionally listen to POLLOUT to avoid the queues getting
stuck.
---
 media/gpu/v4l2/v4l2_stateful_video_decoder.cc | 56 ++++++++++---------
 media/gpu/v4l2/v4l2_stateful_video_decoder.h  |  2 -
 2 files changed, 30 insertions(+), 28 deletions(-)

diff --git a/media/gpu/v4l2/v4l2_stateful_video_decoder.cc b/media/gpu/v4l2/v4l2_stateful_video_decoder.cc
index 9efc80849e..f9107dfe03 100644
--- a/media/gpu/v4l2/v4l2_stateful_video_decoder.cc
+++ b/media/gpu/v4l2/v4l2_stateful_video_decoder.cc
@@ -52,23 +52,34 @@ void* Mmap(int fd,
 }
 
 // This method blocks waiting for an event from either |device_fd| or
-// |wake_event|; then if it's of the type POLLIN (meaning there's data) or
-// POLLPRI (meaning a resolution change event) and from |device_fd|, this
-// function calls |dequeue_callback| or |resolution_change_callback|,
-// respectively. Since it blocks, it needs to work on its own
-// SingleThreadTaskRunner, in this case |event_task_runner_|.
+// |wake_event|; then if it's from |device_fd| and of the type POLLIN
+// (meaning there's data) or POLLPRI (meaning a resolution change event), this
+// function calls |dequeue_callback| or |resolution_change_callback|.
+
+// If |enqueue_callback| is not null, this function also listens to POLLOUT
+// events (meaning the OUTPUT queue can accept encoded chunks); this event
+// could technically be ignored -- except for Hana MTK8173, where for some
+// reason it must be listened to and acted upon it to avoid events from
+// stopping being produced altogether.
+//
+// Since this function blocks, it needs to work on its own SequencedTaskRunner,
+// in this case |event_task_runner_|.
 // TODO(mcasas): Add an error callback too.
 void WaitOnceForEvents(int device_fd,
                        int wake_event,
                        base::OnceClosure dequeue_callback,
+                       base::OnceClosure enqueue_callback,
                        base::OnceClosure resolution_change_callback) {
   VLOGF(5) << "Going to poll()";
 
   // POLLERR, POLLHUP, or POLLNVAL are always return-able and anyway ignored
   // when set in pollfd.events.
   // https://www.kernel.org/doc/html/v5.15/userspace-api/media/v4l/func-poll.html
-  struct pollfd pollfds[] = {{.fd = device_fd, .events = POLLIN | POLLPRI},
-                             {.fd = wake_event, .events = POLLIN}};
+  const short poll_events_to_listen_for =
+      POLLIN | POLLPRI | (enqueue_callback.is_null() ? 0x0 : POLLOUT);
+  struct pollfd pollfds[] = {
+      {.fd = device_fd, .events = poll_events_to_listen_for},
+      {.fd = wake_event, .events = POLLIN}};
   constexpr int kInfiniteTimeout = -1;
   if (HANDLE_EINTR(poll(pollfds, std::size(pollfds), kInfiniteTimeout)) <
       kIoctlOk) {
@@ -79,13 +90,16 @@ void WaitOnceForEvents(int device_fd,
   const auto events_from_device = pollfds[0].revents;
   const auto other_events = pollfds[1].revents;
   // At least Qualcomm Venus likes to bundle events.
-  const auto pollin_or_pollpri_event = events_from_device & (POLLIN | POLLPRI);
-  if (pollin_or_pollpri_event) {
+  if (events_from_device & poll_events_to_listen_for) {
     // "POLLIN There is data to read."
+    // "POLLOUT Normal data may be written without blocking."
     //  https://man7.org/linux/man-pages/man2/poll.2.html
     if (events_from_device & POLLIN) {
       std::move(dequeue_callback).Run();
     }
+    if (events_from_device & POLLOUT) {
+      std::move(enqueue_callback).Run();
+    }
     // "If an event occurred (see ioctl VIDIOC_DQEVENT) then POLLPRI will be set
     //  in the revents field and poll() will return."
     // https://www.kernel.org/doc/html/v5.15/userspace-api/media/v4l/func-poll.html
@@ -352,17 +366,6 @@ void V4L2StatefulVideoDecoder::Initialize(const VideoDecoderConfig& config,
       std::move(init_cb).Run(DecoderStatus::Codes::kFailedToCreateDecoder);
       return;
     }
-
-    struct v4l2_capability caps = {};
-    if (HandledIoctl(device_fd_.get(), VIDIOC_QUERYCAP, &caps) != kIoctlOk) {
-      PLOG(ERROR) << "Failed querying caps";
-      std::move(init_cb).Run(DecoderStatus::Codes::kFailedToCreateDecoder);
-      return;
-    }
-
-    is_mtk8173_ = base::Contains(
-        std::string(reinterpret_cast<const char*>(caps.card)), "8173");
-    DVLOGF_IF(1, is_mtk8173_) << "This is an MTK8173 device (Hana, Oak)";
   }
 
   if (IsInitialized()) {
@@ -873,11 +876,8 @@ size_t V4L2StatefulVideoDecoder::GetNumberOfReferenceFrames() {
   // reference frames is constant and 8 (for VP8 is 4); for H.264 and other
   // ITU-T codecs, it depends on the bitstream. Here we query it from the
   // driver anyway.
-  constexpr size_t kDefaultNumReferenceFrames = 8;
-  constexpr size_t kDefaultNumReferenceFramesMTK8173 = 16;
-  size_t num_codec_reference_frames = is_mtk8173_
-                                          ? kDefaultNumReferenceFramesMTK8173
-                                          : kDefaultNumReferenceFrames;
+  constexpr size_t kDefaultNumReferenceFrames = 16;
+  size_t num_codec_reference_frames = kDefaultNumReferenceFrames;
 
   struct v4l2_ext_control ctrl = {.id = V4L2_CID_MIN_BUFFERS_FOR_CAPTURE};
   struct v4l2_ext_controls ext_ctrls = {.count = 1, .controls = &ctrl};
@@ -903,6 +903,10 @@ void V4L2StatefulVideoDecoder::RearmCAPTUREQueueMonitoring() {
   auto dequeue_callback = base::BindPostTaskToCurrentDefault(base::BindOnce(
       &V4L2StatefulVideoDecoder::TryAndDequeueCAPTUREQueueBuffers,
       weak_ptr_factory_for_events_.GetWeakPtr()));
+  auto enqueue_callback = base::BindPostTaskToCurrentDefault(base::BindOnce(
+        base::IgnoreResult(
+            &V4L2StatefulVideoDecoder::TryAndEnqueueOUTPUTQueueBuffers),
+        weak_ptr_factory_for_events_.GetWeakPtr()));
   // |client_| needs to be told of a hypothetical resolution change (to wait for
   // frames in flight etc). Once that's done they will ping us via
   // ApplyResolutionChange(). We use a trampoline lambda to make sure
@@ -939,7 +943,7 @@ void V4L2StatefulVideoDecoder::RearmCAPTUREQueueMonitoring() {
   cancelable_task_tracker_.PostTask(
       event_task_runner_.get(), FROM_HERE,
       base::BindOnce(&WaitOnceForEvents, device_fd_.get(), wake_event_.get(),
-                     std::move(dequeue_callback),
+                     std::move(dequeue_callback), std::move(enqueue_callback),
                      std::move(resolution_change_callback)));
 }
 
diff --git a/media/gpu/v4l2/v4l2_stateful_video_decoder.h b/media/gpu/v4l2/v4l2_stateful_video_decoder.h
index 35c65c35d2..90da4c80b6 100644
--- a/media/gpu/v4l2/v4l2_stateful_video_decoder.h
+++ b/media/gpu/v4l2/v4l2_stateful_video_decoder.h
@@ -152,8 +152,6 @@ class MEDIA_GPU_EXPORT V4L2StatefulVideoDecoder : public VideoDecoderMixin {
   VideoDecoderConfig config_ GUARDED_BY_CONTEXT(sequence_checker_);
   PipelineOutputCB output_cb_ GUARDED_BY_CONTEXT(sequence_checker_);
   DecodeCB flush_cb_ GUARDED_BY_CONTEXT(sequence_checker_);
-  // Set to true when the driver identifies itself as a Mediatek 8173.
-  bool is_mtk8173_ GUARDED_BY_CONTEXT(sequence_checker_) = false;
 
   // Used only on V4L2_MEMORY_MMAP queues (e.g. Hana MT8173) to grab the visible
   // rectangle upon |CAPTURE_queue_| configuration in InitializeCAPTUREQueue().
-- 
2.45.2

